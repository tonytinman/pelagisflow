# NovaFlow Write Pattern: SCD Type 2 (with Surrogate Keys)

---

**Page Owner**: Data Engineering Team
**Last Updated**: February 2026
**Version**: 1.0
**Related Pages**:
- [Write Patterns Overview](CONFLUENCE_WRITE_PATTERNS_OVERVIEW.md)
- [T2CL Write Pattern](CONFLUENCE_WRITE_PATTERN_T2CL.md)
- [SCD4 Write Pattern](CONFLUENCE_WRITE_PATTERN_SCD4.md)
- [Data Contracts Guide](#)

---

## Table of Contents

1. [Overview](#overview)
2. [When to Use](#when-to-use)
3. [How It Works](#how-it-works)
4. [Surrogate Key Generation](#surrogate-key)
5. [Change Detection Algorithm](#change-detection)
6. [Soft Delete Detection](#soft-delete)
7. [Materialized View](#materialized-view)
8. [Contract Configuration](#contract-configuration)
9. [Parameters](#parameters)
10. [Return Statistics](#return-statistics)
11. [Schema Evolution](#schema-evolution)
12. [Examples](#examples)
13. [SCD2 vs T2CL: When to Choose Which](#scd2-vs-t2cl)
14. [FAQs](#faqs)

---

## Overview {#overview}

The **SCD Type 2** pattern extends T2CL with automatic **surrogate key generation**. Every row version receives a unique, auto-incrementing `sk` (surrogate key) column powered by Delta Lake's `GENERATED ALWAYS AS IDENTITY`. This makes SCD2 the right choice when dimension tables need integer keys for efficient star schema joins.

| Property | Value |
|----------|-------|
| **Contract Value** | `scd2` |
| **Writer Class** | `SCD2Writer` |
| **Delta Write Mode** | SQL `INSERT INTO` (to trigger IDENTITY) |
| **History Tracking** | Yes — full change history with effective dates |
| **Surrogate Key** | Yes — `sk BIGINT GENERATED ALWAYS AS IDENTITY` |
| **Materialized View** | Yes — `mv_{schema}.{table}_curr` (includes `sk`) |
| **Metadata Columns Added** | `sk`, `effective_from`, `effective_to`, `is_current`, `deletion_flag` |
| **Required Hash Columns** | `natural_key_hash`, `change_key_hash`, `partition_key` |

### When to Use {#when-to-use}

- Dimensional tables in a **star schema** where fact tables reference dimensions by surrogate key
- When downstream systems require a stable integer key for joins (rather than a hash or composite natural key)
- When each version of a dimension record needs its own unique identifier

### When NOT to Use

- Dimensions that don't participate in star schema joins (use T2CL — simpler, no IDENTITY overhead)
- Append-only data (use Append)
- Full refresh scenarios (use Overwrite)

---

## How It Works {#how-it-works}

### First Load

```
Incoming DataFrame
        │
        ▼
┌────────────────────────────┐
│ Add metadata columns:      │
│  effective_from = today    │
│  effective_to = 9999-12-31 │
│  is_current = true         │
│  deletion_flag = false     │
└──────────┬─────────────────┘
           │
           ▼
┌────────────────────────────┐
│ CREATE TABLE with DDL      │
│  sk BIGINT GENERATED       │
│    ALWAYS AS IDENTITY      │
│  {all other columns}      │
│  PARTITIONED BY            │
│    (partition_key)         │
└──────────┬─────────────────┘
           │
           ▼
┌────────────────────────────┐
│ INSERT INTO (excl. sk)     │
│ sk auto-generated by Delta │
└──────────┬─────────────────┘
           │
           ▼
┌────────────────────────────┐
│ Create materialized view   │
│ (includes sk, excludes     │
│  SCD2 metadata columns)    │
└────────────────────────────┘
```

### Subsequent Loads

The change detection and row lifecycle logic is identical to T2CL, with one critical difference: **all inserts use SQL `INSERT INTO`** (omitting the `sk` column) so that Delta Lake generates new surrogate keys automatically.

```
Incoming DataFrame              Current Active Records
        │                                │
        ▼                                ▼
┌──────────────────────────────────────────────┐
│            LEFT JOIN                          │
│  ON natural_key_hash equality                 │
└──────┬──────────────┬───────────────┬────────┘
       │              │               │
  ┌────▼────┐   ┌─────▼─────┐   ┌────▼─────┐
  │   NEW   │   │  CHANGED  │   │ UNCHANGED│
  └────┬────┘   └─────┬─────┘   └──────────┘
       │              │
       │         Close old rows
       │         (is_current=false)
       │              │
       ▼              ▼
┌──────────────────────────┐
│   UNION new + changed    │
│   (+ soft deletes)       │
└──────────┬───────────────┘
           │
           ▼
┌──────────────────────────┐
│ INSERT INTO {table}      │
│   ({cols excl. sk})      │
│ SELECT {cols excl. sk}   │
│ FROM staging_view        │
│                          │
│ sk auto-generated ←──────│── Delta IDENTITY
└──────────┬───────────────┘
           │
           ▼
┌──────────────────────────┐
│ Refresh materialized view│
└──────────────────────────┘
```

---

## Surrogate Key Generation {#surrogate-key}

### How It Works

The `sk` column uses Delta Lake's native `IDENTITY` column feature:

```sql
sk BIGINT GENERATED ALWAYS AS IDENTITY
```

| Property | Detail |
|----------|--------|
| **Type** | `BIGINT` — supports billions of records |
| **Generation** | Automatic on `INSERT` — no application logic required |
| **Uniqueness** | Guaranteed unique across concurrent writers |
| **Cluster Safety** | Delta Lake manages IDENTITY at the transaction level — no race conditions |
| **Monotonicity** | Generally increasing, but **not guaranteed sequential** (gaps possible after failed transactions) |

### Why IDENTITY (Not Application-Level Keys)?

| Approach | Problem |
|----------|---------|
| `MAX(sk) + row_number()` | Race condition — two concurrent writes get the same range |
| UUIDs | Not integer — poor join performance, not sortable |
| Sequence tables | Bottleneck under concurrency, complex to manage |
| **Delta IDENTITY** | Cluster-safe, zero application logic, automatic |

### Table Creation DDL

The `SCD2Writer` generates and executes DDL like this on first load:

```sql
CREATE TABLE IF NOT EXISTS catalog.schema.table (
    sk BIGINT GENERATED ALWAYS AS IDENTITY,
    customer_id BIGINT,
    customer_name STRING,
    email STRING,
    natural_key_hash STRING,
    change_key_hash STRING,
    partition_key STRING,
    effective_from DATE,
    effective_to DATE,
    is_current BOOLEAN,
    deletion_flag BOOLEAN
)
USING DELTA
PARTITIONED BY (partition_key)
```

### Insert Mechanism

All inserts use SQL `INSERT INTO` (not DataFrame append) to trigger IDENTITY generation:

```sql
INSERT INTO catalog.schema.table
    (customer_id, customer_name, email, natural_key_hash, change_key_hash,
     partition_key, effective_from, effective_to, is_current, deletion_flag)
SELECT
    customer_id, customer_name, email, natural_key_hash, change_key_hash,
    partition_key, effective_from, effective_to, is_current, deletion_flag
FROM scd2_to_insert
```

Note: `sk` is deliberately **excluded** from the column list — Delta generates it.

### Type Mapping

The writer maps Spark types to SQL types for the DDL:

| Spark Type | SQL Type |
|-----------|----------|
| `StringType` | `STRING` |
| `IntegerType` | `INT` |
| `LongType` | `BIGINT` |
| `DoubleType` | `DOUBLE` |
| `FloatType` | `FLOAT` |
| `BooleanType` | `BOOLEAN` |
| `DateType` | `DATE` |
| `TimestampType` | `TIMESTAMP` |
| `BinaryType` | `BINARY` |
| `DecimalType(p,s)` | `DECIMAL(p,s)` |

---

## Change Detection Algorithm {#change-detection}

The change detection logic is identical to T2CL. See the [T2CL Change Detection documentation](CONFLUENCE_WRITE_PATTERN_T2CL.md#change-detection) for full details.

| Condition | Classification | Action |
|-----------|---------------|--------|
| `natural_key_hash` not in current table | **NEW** | Insert (sk auto-generated) |
| `natural_key_hash` matches, `change_key_hash` differs | **CHANGED** | Close old row, insert new row (new sk) |
| Both hashes match | **UNCHANGED** | No action |

> **Key difference from T2CL**: Each new row version gets a **new surrogate key**. The old row retains its original `sk`.

---

## Soft Delete Detection {#soft-delete}

Soft delete detection works identically to T2CL. When `soft_delete=True`:

1. Missing natural keys are identified
2. Existing rows are closed (`is_current=false`, `deletion_flag=true`)
3. Tombstone rows are inserted with **new surrogate keys** and `deletion_flag=true`

Note: Tombstone rows exclude the `sk` column from the source — they receive new auto-generated keys.

---

## Materialized View {#materialized-view}

The SCD2 materialized view works like T2CL's, with one important difference: **the `sk` column is included** in the view.

### View Definition

```sql
CREATE OR REPLACE MATERIALIZED VIEW {catalog}.mv_{schema}.{table}_curr AS
SELECT sk, customer_id, customer_name, email, natural_key_hash, change_key_hash, partition_key
FROM {target_table}
WHERE is_current = true AND deletion_flag = false
```

**Included**: `sk` (surrogate key) + all business columns + hash columns
**Excluded**: `effective_from`, `effective_to`, `is_current`, `deletion_flag`

This means downstream fact tables can join to the materialized view using the `sk` column directly:

```sql
SELECT
    f.order_id,
    f.order_total,
    d.customer_name,
    d.email
FROM gold_sales.fact_orders f
JOIN prod_catalog.mv_bronze_sales.customers_curr d
    ON f.customer_sk = d.sk
```

---

## Contract Configuration {#contract-configuration}

### Standard SCD2 Contract

```yaml
apiVersion: v3.0.2
kind: DataContract
name: data.galahad.quolive_manager_industry_type

schema:
  name: bronze_galahad
  table: quolive_manager_industry_type
  format: delta
  properties:
    - name: INDUSTRY_CODE
      type: string
      isPrimaryKey: true
      isChangeTracking: false
    - name: INDUSTRY_DESCRIPTION
      type: string
      isChangeTracking: true
    - name: ENABLED
      type: string
      isChangeTracking: true

customProperties:
  pipelineType: ingestion
  writeStrategy: scd2
  softDelete: true
  volume: XXS
```

---

## Parameters {#parameters}

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `df` | `DataFrame` | *required* | Incoming DataFrame (must include hash columns) |
| `target_table` | `str` or `None` | `None` (from contract) | Fully qualified target table name |
| `natural_key_col` | `str` | `"natural_key_hash"` | Column containing the natural key hash |
| `change_key_col` | `str` | `"change_key_hash"` | Column containing the change tracking hash |
| `partition_col` | `str` | `"partition_key"` | Column to partition by |
| `process_date` | `str` or `None` | `None` (today's date) | Effective date for this load in `YYYY-MM-DD` format |
| `soft_delete` | `bool` | `False` | Enable soft delete detection |

---

## Return Statistics {#return-statistics}

### First Load

```python
{
    "strategy": "scd2",
    "first_load": True,
    "target_table": "catalog.bronze_sales.customers",
    "current_view": "catalog.mv_bronze_sales.customers_curr",
    "records_inserted": 10000,
    "max_surrogate_key": 10000
}
```

### Subsequent Loads

```python
{
    "strategy": "scd2",
    "target_table": "catalog.bronze_sales.customers",
    "current_view": "catalog.mv_bronze_sales.customers_curr",
    "new_records": 250,
    "changed_records": 1500,
    "soft_deleted": 30,
    "records_inserted": 1780,
    "max_surrogate_key": 11780,
    "process_date": "2026-02-09"
}
```

| Field | Type | Description |
|-------|------|-------------|
| `strategy` | `str` | Always `"scd2"` |
| `first_load` | `bool` | Present only on initial load |
| `target_table` | `str` | Fully qualified table name |
| `current_view` | `str` | Materialized view name |
| `new_records` | `int` | Records with new natural keys |
| `changed_records` | `int` | Records with changed attributes |
| `soft_deleted` | `int` | Records detected as deleted |
| `records_inserted` | `int` | Total rows inserted |
| `max_surrogate_key` | `int` | Highest `sk` value in the table after this load |
| `process_date` | `str` | Effective date used for this load |

### PipelineStats Metrics

| Metric | Description |
|--------|-------------|
| `scd2_new` | Count of new records |
| `scd2_changed` | Count of changed records |
| `scd2_deleted` | Count of soft-deleted records |
| `scd2_max_sk` | Maximum surrogate key after write |
| `rows_written` | Total rows inserted |

---

## Schema Evolution {#schema-evolution}

SCD2 uses `mergeSchema: true` on the staging view insert. New columns in the incoming DataFrame are added automatically. However, since the table is created via DDL (with explicit column types), the column must be compatible with existing data.

> **Note**: If a new column appears in the source, the table will gain that column on the next load. Existing rows will have `NULL` for the new column.

---

## Examples {#examples}

### Example 1: SCD2 Write with Soft Delete

```python
writer = IOFactory.create_writer("scd2", context, stats)
write_stats = writer.write(df, soft_delete=True)

print(f"Max surrogate key: {write_stats['max_surrogate_key']}")
print(f"New: {write_stats['new_records']}")
print(f"Changed: {write_stats['changed_records']}")
```

### Example 2: Query the Current View (Star Schema Join)

```sql
-- Fact table joins to dimension via surrogate key
SELECT
    f.order_id,
    f.order_date,
    f.order_total,
    c.customer_name,
    c.email
FROM gold_sales.fact_orders f
INNER JOIN prod_catalog.mv_bronze_sales.customers_curr c
    ON f.customer_sk = c.sk
WHERE f.order_date >= '2026-01-01'
```

### Example 3: Full History for a Single Entity

```sql
SELECT
    sk,
    customer_name,
    email,
    effective_from,
    effective_to,
    is_current,
    deletion_flag
FROM prod_catalog.bronze_sales.customers
WHERE natural_key_hash = 'abc123'
ORDER BY effective_from
```

### Example 4: Point-in-Time Query

```sql
-- What did the customer look like on January 15th?
SELECT *
FROM prod_catalog.bronze_sales.customers
WHERE natural_key_hash = 'abc123'
  AND effective_from <= '2026-01-15'
  AND effective_to > '2026-01-15'
```

---

## SCD2 vs T2CL: When to Choose Which {#scd2-vs-t2cl}

| Aspect | T2CL | SCD2 |
|--------|------|------|
| **Surrogate Key** | None | BIGINT IDENTITY |
| **Primary Use** | General-purpose history | Star schema dimensions |
| **View Includes SK** | N/A | Yes — for fact-dim joins |
| **Insert Method** | DataFrame `.write.append()` | SQL `INSERT INTO` |
| **Performance** | Slightly faster | Slightly slower (IDENTITY overhead) |
| **Cluster Safety** | N/A | Guaranteed (IDENTITY) |
| **Table Creation** | DataFrame write | DDL with IDENTITY column |
| **When to Use** | No downstream fact table joins needed | Fact tables reference this dim by SK |

**Decision**: If any fact table will `JOIN` to this dimension using an integer key → use **SCD2**. Otherwise → use **T2CL**.

---

## FAQs {#faqs}

**Q: Can surrogate keys have gaps?**
A: Yes. Delta Lake IDENTITY does not guarantee sequential values. Gaps can occur after failed transactions or concurrent writes. This is normal and does not affect correctness.

**Q: What is the maximum surrogate key value?**
A: `BIGINT` supports values up to 9,223,372,036,854,775,807. This is effectively unlimited for any practical dimension table.

**Q: Can I use the surrogate key as a primary key in fact tables?**
A: Yes. The `sk` column is unique per row version and is included in the materialized view specifically for this purpose.

**Q: What happens to the surrogate key when a record is updated?**
A: The old row retains its original `sk`. The new version gets a **new, higher** `sk`. Both are in the table — the old one with `is_current=false`, the new one with `is_current=true`.

**Q: Is the max_surrogate_key useful?**
A: It's primarily an observability metric. It tells you how many total row versions exist in the table and can help monitor growth over time.

**Q: Can I re-run the same data safely?**
A: Yes. If no changes are detected, no rows are inserted, and no surrogate keys are consumed. The operation is idempotent.

---

_This is a living document. Last updated: February 2026_

# NovaFlow Core Module

---

**Page Owner**: Nova Framework Team  
**Last Updated**: February 2026  
**Version**: 1.0  
**Related Pages**:
- [NovaFlow Overview](#)
- [Developer Guide](./DEVELOPER_GUIDE.md)
- [Data Privacy Controls](./CONFLUENCE_DATA_PRIVACY.md)

---

## ðŸ“‹ Table of Contents

1. [Overview](#overview)
2. [What Lives in `core`](#what-lives-in-core)
3. [Configuration Model](#configuration-model)
4. [Execution Context](#execution-context)
5. [Execution Results and Status](#execution-results-and-status)
6. [Typical Runtime Flow](#typical-runtime-flow)
7. [Usage Examples](#usage-examples)
8. [Operational Notes](#operational-notes)
9. [FAQ](#faq)

---

## Overview {#overview}

The `nova_framework.core` module provides the foundational runtime primitives used by pipeline orchestration and stages:

- **Configuration** (`FrameworkConfig`) for environment, catalogs, storage templates, and feature flags.
- **Execution context** (`ExecutionContext`) to carry contract details, runtime state, and derived paths/table names.
- **Execution models** (`ExecutionStatus`, `ExecutionResult`) for standardized run outcomes.

> ðŸ’¡ Think of `core` as the runtime contract between orchestration, stages, and platform conventions.

---

## What Lives in `core` {#what-lives-in-core}

### `config.py`
Centralized config dataclasses:
- `CatalogConfig`
- `StorageConfig`
- `ObservabilityConfig`
- `FrameworkConfig`

Global helpers:
- `get_config()` returns singleton config.
- `set_config(config)` overrides singleton.
- `reset_config()` clears singleton.

### `context.py`
Defines `ExecutionContext`, including:
- execution identifiers (`process_queue_id`, `data_contract_name`, `source_ref`, `env`),
- lazy contract bootstrapping,
- derived runtime properties (`catalog`, `data_file_path`, `target_table`),
- shared mutable run state for stages (`set_state`, `get_state`).

### `models.py`
Defines shared execution outcome models:
- `ExecutionStatus` enum (`pending`, `running`, `success`, `failed`, `cancelled`)
- `ExecutionResult` dataclass with timestamps, error details, metrics, and convenience properties.

---

## Configuration Model {#configuration-model}

`FrameworkConfig` is the top-level source of truth for runtime defaults.

### Catalog naming

Catalog names are generated by:

```text
{organization}_{env}_{framework_name}
```

Example:
- organization: `cluk`
- env: `dev`
- framework_name: `nova`

Result:

```text
cluk_dev_nova
```

### Storage path templates

Default raw path pattern:

```text
/Volumes/{catalog}/{schema}/raw/{source_ref}/{table}/
```

This ensures stage implementations can derive deterministic paths without embedding environment-specific logic.

### Observability defaults

`ObservabilityConfig` includes table locations and toggles for:
- logs,
- metrics,
- telemetry,
- pipeline statistics,
- data quality error sinks.

### Feature flags

`FrameworkConfig` currently supports:
- `enable_soft_delete`
- `enable_schema_evolution`
- `enable_data_quality`

These flags allow progressive rollout and environment-specific behavior control.

---

## Execution Context {#execution-context}

`ExecutionContext` is instantiated at pipeline start and passed through execution layers.

### Responsibilities

1. **Load contract metadata** from `data_contract_name` + `env`.
2. **Resolve derived identifiers** used by read/write stages.
3. **Expose mutable `state`** for cross-stage communication.

### Key derived properties

| Property | Purpose |
|---|---|
| `catalog` | Environment-scoped Unity Catalog name |
| `data_file_path` | Source ingestion path based on contract schema/table + source ref |
| `target_table` | Fully-qualified `{catalog}.{schema}.{table}` table |

### State sharing pattern

Stages can safely exchange transient runtime objects via:

```python
context.set_state("dedupe_keys", ["id", "event_ts"])
keys = context.get_state("dedupe_keys", [])
```

Recommended use cases:
- row counts between stages,
- resolved schemas,
- transformation artifacts,
- stage-level diagnostics.

---

## Execution Results and Status {#execution-results-and-status}

Use `ExecutionStatus` and `ExecutionResult` to standardize run reporting and downstream monitoring.

### Status lifecycle

Typical progression:

```text
PENDING â†’ RUNNING â†’ SUCCESS
```

or failure paths:

```text
RUNNING â†’ FAILED
RUNNING â†’ CANCELLED
```

### `ExecutionResult` fields

| Field | Meaning |
|---|---|
| `status` | Final or current execution state |
| `started_at` | Start timestamp |
| `completed_at` | End timestamp (optional while running) |
| `error` | Error text when failed |
| `metrics` | Arbitrary run metrics payload |

Convenience properties:
- `duration_seconds` computes elapsed runtime when completed.
- `success` returns boolean status check.

---

## Typical Runtime Flow {#typical-runtime-flow}

```text
Pipeline Trigger
    â†“
Build/resolve FrameworkConfig
    â†“
Create ExecutionContext(process_queue_id, contract, source_ref, env)
    â†“
Context loads DataContract + derives catalog/path/table
    â†“
Pipeline stages read/write via context and store shared state
    â†“
Orchestrator emits ExecutionResult with status + metrics
```

---

## Usage Examples {#usage-examples}

### Example 1: Environment config override

```python
from nova_framework.core.config import FrameworkConfig, set_config

config = FrameworkConfig.from_env("prod")
set_config(config)
```

### Example 2: Build runtime context

```python
from nova_framework.core.context import ExecutionContext

context = ExecutionContext(
    process_queue_id=12345,
    data_contract_name="data.sales.daily_orders",
    source_ref="landing_api",
    env="dev",
)

print(context.catalog)
print(context.target_table)
print(context.data_file_path)
```

### Example 3: Emit execution result

```python
from datetime import datetime
from nova_framework.core.models import ExecutionResult, ExecutionStatus

result = ExecutionResult(
    status=ExecutionStatus.SUCCESS,
    started_at=datetime(2026, 2, 1, 8, 0, 0),
    completed_at=datetime(2026, 2, 1, 8, 3, 15),
    metrics={"rows_written": 102345, "dq_failures": 12},
)
```

---

## Operational Notes {#operational-notes}

- Prefer `FrameworkConfig.from_env(...)` or explicit constructor injection in tests.
- Call `reset_config()` in unit tests when validating config singleton behavior.
- Keep `ExecutionContext.state` for transient execution-only values; persist durable metadata in observability sinks.
- Avoid hardcoding catalog/schema/table names in stagesâ€”always derive from context/config.

---

## FAQ {#faq}

**Q: When should I use global config helpers vs direct injection?**  
A: Use direct injection for deterministic tests and advanced composition. Use `get_config()` singleton for straightforward runtime defaults.

**Q: Is `ExecutionContext` Databricks-specific?**  
A: It is platform-aware (e.g., Unity Catalog naming and volume paths) but intentionally lightweight and framework-centered.

**Q: Should stage outputs be stored in `state` or metrics?**  
A: Store inter-stage transient objects in `state`. Publish run outcomes and KPIs in `ExecutionResult.metrics` and observability tables.
